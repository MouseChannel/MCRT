#version 460
#extension GL_EXT_debug_printf : enable

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#include "../../Set_binding.h"
#include "../../sampling.glsl"
#include "../common.h"
#include "./binding.h"
#include "./push_constants.h"

layout(set = e_compute, binding = e_skybox) uniform samplerCube skybox;
layout(set = e_compute, binding = e_irradiance_image, rgba8_snorm) uniform imageCube irradiance_image;
// layout(push_constant) uniform _PushContant
// {
//     PushContant_IBL pc;
// };
int image_size = 512;
// void filtered()
// {
//     // debugPrintfEXT("message \n");
//     uint x = gl_GlobalInvocationID.x;
//     uint y = gl_GlobalInvocationID.y;
//     int count = 0;
//     vec3 sum = vec3(0);
//     ivec2 dir[9] = ivec2[](ivec2(-1, -1),
//                            ivec2(0, -1),
//                            ivec2(0, 1),
//                            ivec2(-1, 0),
//                            ivec2(0, 0),
//                            ivec2(1, 0),
//                            ivec2(-1, 1),
//                            ivec2(0, 1),
//                            ivec2(1, 1));
//     for (int j = 0; j < 6; j++) {
//         for (int i = 0; i < 9; i++) {
//             uint xx = clamp(x + dir[i].x, 0, image_size - 1);
//             uint yy = clamp(y + dir[i].y, 0, image_size - 1);
//             vec4 cur = imageLoad(irradiance_image, ivec3(xx, yy, j));
//             if (cur.z > 1e-8) {
//                 count++;
//                 sum += cur.xyz;
//             }
//         }
//         sum /= count;
//         imageStore(irradiance_image, ivec3(x, y, j), vec4(0, 1, 0, 1));
//     }
// }
void main()
{
    // if (gl_GlobalInvocationID.x == 0 && pc.doing_filter == 1)
    //     debugPrintfEXT("message %d\n", pc.doing_filter);
    // if (pc.doing_filter == 1) {
    //     filtered();
    //     return;
    // }
    // int size = 256;
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

    vec3 local_n = vec3(gl_GlobalInvocationID - vec3(image_size / 2)) / image_size;

    mat3 normal_coordinate = getNormalSpace(local_n);
    vec3 world_n = normalize(local_n);
    vec3 irradiance = vec3(0);
    for (int i = 0; i < 64; i++) {
        vec3 out_texcoord = hemisphereSample_cos(uvec3(i, gl_GlobalInvocationID.xy));
        vec3 world_out = normal_coordinate * out_texcoord;
        irradiance += texture(skybox, world_out).xyz;
    }
    irradiance /= 64;

    // if (gl_GlobalInvocationID.x < 2) {
    //     debugPrintfEXT("message %f %f %f | %f %f %f \n", local_n.x, local_n.y, local_n.z, world_n.x, world_n.y, world_n.z);
    // }

    float m_x = abs(world_n.x);
    float m_y = abs(world_n.y);
    float m_z = abs(world_n.z);
    float m = max(max(m_x, m_y), m_z);
    ivec3 pos = ivec3(0, 0, 0);
    world_n *= image_size;

    if (m == m_x) {
        if (world_n.x > 0) {
            pos = ivec3(world_n.y, world_n.z, 0);
        } else {
            pos = ivec3(world_n.y, world_n.z, 1);
        }

    } else if (m == m_y) {
        if (world_n.y > 0) {
            pos = ivec3(world_n.x, world_n.z, 2);
        } else {
            pos = ivec3(world_n.x, world_n.z, 3);
        }

    } else {
        if (world_n.z > 0) {
            pos = ivec3(world_n.x, world_n.y, 4);
        } else {
            pos = ivec3(world_n.x, world_n.y, 5);
        }
    }

    imageStore(irradiance_image, pos + ivec3(image_size / 2, image_size / 2, 0), vec4(irradiance, 1));
}

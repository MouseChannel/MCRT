#version 460
#extension GL_EXT_debug_printf : enable

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
// #include "../../Set_binding.h"
#include "../../sampling.glsl"
#include "../common.h"
#include "./binding.h"
#include "./push_constants.h"

layout(set = 0, binding = e_skybox) uniform samplerCube skybox;
layout(set = 0, binding = e_irradiance_image, rgba8_snorm) uniform imageCube irradiance_image;
// layout(push_constant) uniform _PushContant
// {
//     PushContant_IBL pc;
// };
int image_size = 512;
int batch = 128;
vec3 transfer(vec3 texcoord)
{
    float m_x = abs(texcoord.x);
    float m_y = abs(texcoord.y);
    float m_z = abs(texcoord.z);
    float m = max(max(m_x, m_y), m_z);
    vec3 pos = ivec3(0, 0, 0);
    texcoord *= image_size;

    if (m == m_x) {
        if (texcoord.x > 0) {
            pos = vec3(texcoord.y, texcoord.z, 0);
        } else {
            pos = vec3(texcoord.y, texcoord.z, 1);
        }

    } else if (m == m_y) {
        if (texcoord.y > 0) {
            pos = vec3(texcoord.x, texcoord.z, 2);
        } else {
            pos = vec3(texcoord.x, texcoord.z, 3);
        }

    } else {
        if (texcoord.z > 0) {
            pos = vec3(texcoord.x, texcoord.y, 4);
        } else {
            pos = vec3(texcoord.x, texcoord.y, 5);
        }
    }
    return pos;
}
vec3 re_transfer(ivec3 index)
{
    vec3 res;
    vec2 xy = index.xy;
    xy -= (image_size) / 2;
    xy /= (image_size) / 2;
    switch (index.z) {
    case 0:
        res = vec3(1, -xy.y, -xy.x);
        break;
    case 1:

        res = vec3(-1, -xy.y, xy.x);
        break;
    case 2:
        res = vec3(xy.x, 1, xy.y);
        break;
    case 3:
        res = vec3(xy.x, -1, -xy.y);
        break;
    case 4:
        res = vec3(xy.x, -xy.y, 1);
        break;
    case 5:
        res = vec3(-xy.x, -xy.y, -1);
        break;
    }

    return normalize(res);
}
void main()
{

    vec3 local_n = vec3(gl_GlobalInvocationID - vec3(image_size / 2)) / image_size;

    local_n = normalize(local_n);
    local_n = re_transfer(ivec3(gl_GlobalInvocationID));

    mat3 normal_coordinate = getNormalSpace(local_n);
    vec3 irradiance = vec3(0);
    for (int i = 0; i < batch; i++) {
        vec3 out_texcoord = hemisphereSample_cos(uvec3(i, gl_GlobalInvocationID.xy));
        vec3 world_out = normal_coordinate * out_texcoord;
        irradiance += texture(skybox, world_out).xyz;
    }
    irradiance /= batch;

    imageStore(irradiance_image, ivec3(gl_GlobalInvocationID), vec4(irradiance, 1));
}
